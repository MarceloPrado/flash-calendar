"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[75],{9256:(e,n,t)=>{t.d(n,{z:()=>a});var s=t(1085);const a=e=>{let{alignItems:n,children:t,justifyContent:a="flex-start",spacing:r=0}=e;return(0,s.jsx)("div",{style:{gap:r,flexDirection:"row",justifyContent:a,alignItems:n,display:"flex"},children:t})}},2701:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>h});var s=t(1085),a=t(1184),r=t(9256);const o=t.p+"assets/medias/imperative-scroll-a63400041077d2029ab635211d31a7da.mp4",i={sidebar_position:4},d="Tips and Tricks",l={id:"fundamentals/tips-and-tricks",title:"Tips and Tricks",description:"Exploring the libary and props",source:"@site/docs/fundamentals/tips-and-tricks.mdx",sourceDirName:"fundamentals",slug:"/fundamentals/tips-and-tricks",permalink:"/flash-calendar/fundamentals/tips-and-tricks",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"defaultSidebar",previous:{title:"Customization",permalink:"/flash-calendar/fundamentals/customization"},next:{title:"Troubleshooting",permalink:"/flash-calendar/fundamentals/troubleshooting"}},c={},h=[{value:"Exploring the libary and props",id:"exploring-the-libary-and-props",level:2},{value:"Date IDs vs Dates",id:"date-ids-vs-dates",level:2},{value:"Programmatically scrolling to a date",id:"programmatically-scrolling-to-a-date",level:2},{value:"Setting Border Radius to <code>Calendar.Item.Day</code>",id:"setting-border-radius-to-calendaritemday",level:2},{value:"Avoiding dark mode",id:"avoiding-dark-mode",level:2},{value:"Listening to the visible months",id:"listening-to-the-visible-months",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"tips-and-tricks",children:"Tips and Tricks"}),"\n",(0,s.jsx)(n.h2,{id:"exploring-the-libary-and-props",children:"Exploring the libary and props"}),"\n",(0,s.jsxs)(n.p,{children:["All props from Flash Calendar are documented and prefixed with ",(0,s.jsx)(n.code,{children:"calendar"})," to\nincrease IDE discoverability. After installing the package, just type ",(0,s.jsx)(n.code,{children:"<Calendar calendar"})," and open your autocomplete to see the available options."]}),"\n",(0,s.jsx)(n.h2,{id:"date-ids-vs-dates",children:"Date IDs vs Dates"}),"\n",(0,s.jsxs)(n.p,{children:["Date and timezones are a confusing topic. This is why Flash Calendar is careful to name things consistently. All props and callbacks used by the library follows the same convention of using a date ID instead of a ",(0,s.jsx)(n.code,{children:"Date"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Date ID is a simple ",(0,s.jsx)(n.code,{children:"YYYY-MM-DD"})," representation of a given date. Flash Calendar exposes two functions to convert between Date and Date ID."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { toDateId, fromDateId } from "@marceloterreiro/flash-calendar";\n\nconst januaryFirstAsDate = fromDateId("2024-01-01"); // Date object\nconst januaryFirstAsId = toDateId(januaryFirstAsDate); // "2024-01-01"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["It's ",(0,s.jsxs)(n.strong,{children:["highly recommended to use ",(0,s.jsx)(n.code,{children:"toDateId"})," and ",(0,s.jsx)(n.code,{children:"fromDateId"})," when interacting with the library"]}),". These functions were purposefully created to avoid timezones and other date-related issues."]}),"\n",(0,s.jsx)(n.p,{children:"For instance, consider this code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const endOfJanuary = new Date("2024-01-31");\n\n// \u274c Don\'t do this, for some dates and timezones, this will return unexpected results\nconst endOfJanuaryId = endOfJanuary.toISOString().slice(0, 10); // 2024-02-01 or 2024-01-31, depending on the timezone\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The code above is not completely safe. It can return ",(0,s.jsx)(n.code,{children:"2024-02-01"})," for some timezones. Instead, use ",(0,s.jsx)(n.code,{children:"toDateId"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'const endOfJanuaryId = toDateId("2024-01-31");\nconst endOfJanuary = fromDateId(endOfJanuaryId); // Date object\n'})}),"\n",(0,s.jsxs)(n.p,{children:["These two convertions functions were ",(0,s.jsx)(n.a,{href:"https://github.com/MarceloPrado/flash-calendar/blob/ee87cb1a695a42840f00f17bbaeb1a795a1e3ba0/packages/flash-calendar/src/helpers/dates.test.ts#L30-L130",children:"battle-tested"})," to return the expected results, regardless of the timezone."]}),"\n",(0,s.jsx)(n.h2,{id:"programmatically-scrolling-to-a-date",children:"Programmatically scrolling to a date"}),"\n",(0,s.jsxs)(n.p,{children:["Flash Calendar exposes a ",(0,s.jsx)(n.code,{children:"ref"})," that allows imperative scrolling to a desired\ndate (",(0,s.jsx)(n.code,{children:".scrollToDate"}),"), a month (",(0,s.jsx)(n.code,{children:".scrollToMonth"}),"), or an offset\n(",(0,s.jsx)(n.code,{children:".scrollToOffset"}),")."]}),"\n",(0,s.jsxs)(r.z,{spacing:24,alignItems:"flex-start",children:[(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { addMonths, subMonths, startOfMonth } from "date-fns";\nimport type { CalendarListRef } from "@marceloterreiro/flash-calendar";\nimport { Calendar, toDateId } from "@marceloterreiro/flash-calendar";\nimport { useRef, useState } from "react";\nimport { Button, Text, View } from "react-native";\n\nexport function ImperativeScrolling() {\n  const [currentMonth, setCurrentMonth] = useState(startOfMonth(new Date()));\n  const ref = useRef<CalendarListRef>(null);\n\n  const onCalendarDayPress = useCallback((dateId: string) => {\n    ref.current?.scrollToDate(fromDateId(dateId), true);\n  }, []);\n\n  return (\n    <View style={{ paddingTop: 20, flex: 1 }}>\n      <View style={{ flexDirection: "row", gap: 12 }}>\n        <Button\n          onPress={() => {\n            const pastMonth = subMonths(currentMonth, 1);\n            setCurrentMonth(pastMonth);\n            ref.current?.scrollToMonth(pastMonth, true);\n          }}\n          title="Past month"\n        />\n        <Text>Current: {toDateId(currentMonth)}</Text>\n        <Button\n          onPress={() => {\n            const nextMonth = addMonths(currentMonth, 1);\n            setCurrentMonth(nextMonth);\n            ref.current?.scrollToMonth(nextMonth, true);\n          }}\n          title="Next month"\n        />\n      </View>\n      <View style={{ flex: 1, width: "100%" }}>\n        <Calendar.List\n          calendarInitialMonthId={toDateId(currentMonth)}\n          onCalendarDayPress={onCalendarDayPress}\n          ref={ref}\n        />\n      </View>\n    </View>\n  );\n}\n'})})}),(0,s.jsx)("video",{controls:!0,width:250,children:(0,s.jsx)("source",{src:o,type:"video/mp4"})})]}),"\n",(0,s.jsxs)(n.p,{children:["You can also pass an ",(0,s.jsx)(n.code,{children:"additionalOffset"})," to fine-tune the scroll position:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'.scrollToDate(fromDateId("2024-07-01"), true, { additionalOffset: 4 })\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"setting-border-radius-to-calendaritemday",children:["Setting Border Radius to ",(0,s.jsx)(n.code,{children:"Calendar.Item.Day"})]}),"\n",(0,s.jsxs)(n.p,{children:["To apply a border radius to the ",(0,s.jsx)(n.code,{children:"Calendar.Item.Day"})," component, it's necessary to\nspecify the radius for all four corners. Here's an example of how to achieve\nthis:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"itemDay: {\n  base: () => ({\n    container: {\n      borderTopRightRadius: 10,\n      borderBottomRightRadius: 10,\n      borderTopLeftRadius: 10,\n      borderBottomLeftRadius: 10,\n    },\n  }),\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"avoiding-dark-mode",children:"Avoiding dark mode"}),"\n",(0,s.jsxs)(n.p,{children:["If your app doesn't support dynamic themes, you can override Flash Calendar's\ncolor scheme by passing a ",(0,s.jsx)(n.code,{children:"calendarColorScheme"})," prop:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export const LightModeOnly = () => {\n  const { calendarActiveDateRanges, onCalendarDayPress } = useDateRange({\n    startId: "2024-02-04",\n    endId: "2024-02-09",\n  });\n\n  return (\n    <Calendar\n      calendarActiveDateRanges={calendarActiveDateRanges}\n      calendarColorScheme="light"\n      calendarMonthId={toDateId(startOfThisMonth)}\n      onCalendarDayPress={onCalendarDayPress}\n    />\n  );\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"When set, Flash Calendar's theming system will use this scheme instead of the\nuser system's theme."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": you should avoid using this prop. Instead, your app should\nsupport dynamic themes that react to the user's system preferences. The prop is\nprovided as an escape hatch for apps that doesn't support dynamic themes yet."]}),"\n",(0,s.jsx)(n.h2,{id:"listening-to-the-visible-months",children:"Listening to the visible months"}),"\n",(0,s.jsxs)(n.p,{children:["You can listen to which months are currently visible by hooking into the ",(0,s.jsx)(n.a,{href:"https://shopify.github.io/flash-list/docs/usage#onviewableitemschanged",children:(0,s.jsx)(n.code,{children:"onViewableItemsChange"})})," prop:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export const ListenToVisibleMonth = () => {\n  const [selectedDate, setSelectedDate] = useState(today);\n  const [visibleMonth, setVisibleMonth] = useState(today);\n\n  const handleViewableItemsChanged = useCallback<\n    NonNullable<FlashListProps<CalendarMonth>["onViewableItemsChanged"]>\n  >(({ viewableItems }) => {\n    const firstVisibleItem = viewableItems.find((item) => item.isViewable);\n\n    if (firstVisibleItem) {\n      setVisibleMonth(firstVisibleItem.item.id);\n    }\n  }, []);\n\n  return (\n    <View style={{ flex: 1, gap: 24 }}>\n      <View style={{ gap: 12 }}>\n        <Text>Selected date: {selectedDate}</Text>\n        <Text>Visible month: {visibleMonth}</Text>\n      </View>\n      <Calendar.List\n        calendarActiveDateRanges={[{ startId: today, endId: today }]}\n        calendarInitialMonthId="2024-11-01"\n        onCalendarDayPress={setSelectedDate}\n        onViewableItemsChanged={handleViewableItemsChanged}\n      />\n    </View>\n  );\n};\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(4041);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);