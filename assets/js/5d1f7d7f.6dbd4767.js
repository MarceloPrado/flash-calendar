"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[899],{1184:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>o});var t=a(4041);const s={},r=t.createContext(s);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(r.Provider,{value:n},e.children)}},1703:(e,n,a)=>{a.d(n,{z:()=>s});var t=a(1085);const s=({alignItems:e,children:n,justifyContent:a="flex-start",spacing:s=0})=>(0,t.jsx)("div",{style:{gap:s,flexDirection:"row",justifyContent:a,alignItems:e,display:"flex"},children:n})},7993:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>h,contentTitle:()=>d,default:()=>m,frontMatter:()=>c,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"fundamentals/limitations","title":"Limitations","description":"The following are the current known limitations of Flash Calendar. Please, feel free to contribute and help address them.","source":"@site/docs/fundamentals/limitations.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/limitations","permalink":"/flash-calendar/fundamentals/limitations","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"defaultSidebar","previous":{"title":"Troubleshooting","permalink":"/flash-calendar/fundamentals/troubleshooting"}}');var s=a(1085),r=a(1184),l=a(1703);const o=a.p+"assets/medias/limitation-backward-scrolling-4a152913e4627589acf035a426a5cbb7.mp4",i=a.p+"assets/medias/limitation-backward-scrolling-workaround-55c03f3e9ee9a21a26c03850c5e414e1.mp4",c={sidebar_position:6},d="Limitations",h={},u=[{value:"Infinite scrolling doesn&#39;t work backwards",id:"infinite-scrolling-doesnt-work-backwards",level:2},{value:"Work-around",id:"work-around",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"limitations",children:"Limitations"})}),"\n",(0,s.jsx)(n.p,{children:"The following are the current known limitations of Flash Calendar. Please, feel free to contribute and help address them."}),"\n",(0,s.jsx)(n.h2,{id:"infinite-scrolling-doesnt-work-backwards",children:"Infinite scrolling doesn't work backwards"}),"\n",(0,s.jsxs)(n.p,{children:["We currently use ",(0,s.jsx)(n.code,{children:"onEndReached"})," to append new months, but also need a ",(0,s.jsx)(n.code,{children:"onStartReached"})," to prepend months. We need a reliable way to keep the scroll position intact when the user scrolls\nbackwards. Functionality-wise, ",(0,s.jsx)(n.code,{children:"prependMonths"})," is already built. We just need to hook it up to the scroll event."]}),"\n",(0,s.jsxs)(n.p,{children:["Waiting for Flash List's ",(0,s.jsx)(n.a,{href:"https://github.com/Shopify/flash-list/pull/824",children:"#824"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Here's what happens when you try to scroll backwards:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Expected"}),": The calendar scrolls to previous months infinitely at ",(0,s.jsx)(n.code,{children:"calendarPastScrollRangeInMonths"})," increments."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actual"}),": The calendar doesn't scroll past the initial month."]}),"\n"]}),"\n",(0,s.jsxs)(l.z,{spacing:24,alignItems:"flex-start",children:[(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export const ScrollingBackwardsLimitation = () => {\n  return (\n    <VStack alignItems="stretch" grow spacing={12}>\n      <Text>Notice how it doesn\'t scroll past January</Text>\n\n      <Calendar.List\n        calendarFutureScrollRangeInMonths={1}\n        calendarInitialMonthId="2024-02-01"\n        calendarMaxDateId="2024-05-01"\n        calendarPastScrollRangeInMonths={1}\n        onCalendarDayPress={loggingHandler("onCalendarDayPress")}\n      />\n    </VStack>\n  );\n};\n'})})}),(0,s.jsx)("video",{controls:!0,width:300,children:(0,s.jsx)("source",{src:o,type:"video/mp4"})})]}),"\n",(0,s.jsx)(n.h3,{id:"work-around",children:"Work-around"}),"\n",(0,s.jsxs)(n.p,{children:["As a work-around, you can use ",(0,s.jsx)(n.code,{children:"calendarPastScrollRangeInMonths"})," and\n",(0,s.jsx)(n.code,{children:"calendarMinDateId"})," to preload all the months you need to scroll back to."]}),"\n",(0,s.jsxs)(n.p,{children:["This can have a performance impact since the month list is held in memory. However, we have an\n",(0,s.jsx)(n.a,{href:"https://github.com/MarceloPrado/flash-calendar/blob/70bbf3f5e19a6c10592a6ee606c57d7c880ff3d9/apps/example/src/components/PerfTestCalendar/PerfTestCalendarList.stories.tsx#L69-L102",children:"example"}),"\nrendering 2.000 months (166 years) just fine. Flash List performs really well with large lists, so it's likely that the main bottelneck will be how many items can be held in memory."]}),"\n",(0,s.jsxs)(l.z,{spacing:24,alignItems:"flex-start",children:[(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'export const ScrollingBackwardsWorkaround = () => {\n  return (\n    <VStack alignItems="stretch" grow spacing={12}>\n      <Text>This preloads all past months between Jan 1st 2020 and today</Text>\n\n      <Calendar.List\n        calendarFutureScrollRangeInMonths={1}\n        calendarInitialMonthId="2024-02-01"\n        calendarMaxDateId="2024-05-01"\n        calendarMinDateId="2020-01-01"\n        calendarPastScrollRangeInMonths={50}\n        onCalendarDayPress={loggingHandler("onCalendarDayPress")}\n      />\n    </VStack>\n  );\n};\n'})})}),(0,s.jsx)("video",{controls:!0,width:300,children:(0,s.jsx)("source",{src:i,type:"video/mp4"})})]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);